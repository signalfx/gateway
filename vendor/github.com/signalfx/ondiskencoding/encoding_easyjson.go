// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package encoding

import (
	json "encoding/json"
	easyjson "github.com/mailru/easyjson"
	jlexer "github.com/mailru/easyjson/jlexer"
	jwriter "github.com/mailru/easyjson/jwriter"
	trace "github.com/signalfx/golib/trace"
)

// suppress unused package warning
var (
	_ *json.RawMessage
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ easyjson.Marshaler
)

func easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding(in *jlexer.Lexer, out *SpanIdentity) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "Service":
			out.Service = string(in.String())
		case "Operation":
			out.Operation = string(in.String())
		case "HttpMethod":
			out.HttpMethod = string(in.String())
		case "Kind":
			out.Kind = string(in.String())
		case "Error":
			out.Error = bool(in.Bool())
		case "ServiceMesh":
			out.ServiceMesh = bool(in.Bool())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding(out *jwriter.Writer, in SpanIdentity) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Service != "" {
		const prefix string = ",\"Service\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.Service))
	}
	if in.Operation != "" {
		const prefix string = ",\"Operation\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Operation))
	}
	if in.HttpMethod != "" {
		const prefix string = ",\"HttpMethod\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.HttpMethod))
	}
	if in.Kind != "" {
		const prefix string = ",\"Kind\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Kind))
	}
	if in.Error {
		const prefix string = ",\"Error\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Bool(bool(in.Error))
	}
	if in.ServiceMesh {
		const prefix string = ",\"ServiceMesh\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Bool(bool(in.ServiceMesh))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v SpanIdentity) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v SpanIdentity) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *SpanIdentity) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *SpanIdentity) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding(l, v)
}
func easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding1(in *jlexer.Lexer, out *SampleList) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		in.Skip()
		*out = nil
	} else {
		in.Delim('[')
		if *out == nil {
			if !in.IsDelim(']') {
				*out = make(SampleList, 0, 8)
			} else {
				*out = SampleList{}
			}
		} else {
			*out = (*out)[:0]
		}
		for !in.IsDelim(']') {
			var v1 *SampleEntry
			if in.IsNull() {
				in.Skip()
				v1 = nil
			} else {
				if v1 == nil {
					v1 = new(SampleEntry)
				}
				(*v1).UnmarshalEasyJSON(in)
			}
			*out = append(*out, v1)
			in.WantComma()
		}
		in.Delim(']')
	}
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding1(out *jwriter.Writer, in SampleList) {
	if in == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
		out.RawString("null")
	} else {
		out.RawByte('[')
		for v2, v3 := range in {
			if v2 > 0 {
				out.RawByte(',')
			}
			if v3 == nil {
				out.RawString("null")
			} else {
				(*v3).MarshalEasyJSON(out)
			}
		}
		out.RawByte(']')
	}
}

// MarshalJSON supports json.Marshaler interface
func (v SampleList) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding1(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v SampleList) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding1(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *SampleList) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding1(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *SampleList) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding1(l, v)
}
func easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding2(in *jlexer.Lexer, out *SampleEntry) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "ID":
			if in.IsNull() {
				in.Skip()
				out.ID = nil
			} else {
				if out.ID == nil {
					out.ID = new(SpanIdentity)
				}
				(*out.ID).UnmarshalEasyJSON(in)
			}
		case "Samples":
			if in.IsNull() {
				in.Skip()
				out.Samples = nil
			} else {
				in.Delim('[')
				if out.Samples == nil {
					if !in.IsDelim(']') {
						out.Samples = make([]int64, 0, 8)
					} else {
						out.Samples = []int64{}
					}
				} else {
					out.Samples = (out.Samples)[:0]
				}
				for !in.IsDelim(']') {
					var v4 int64
					v4 = int64(in.Int64())
					out.Samples = append(out.Samples, v4)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding2(out *jwriter.Writer, in SampleEntry) {
	out.RawByte('{')
	first := true
	_ = first
	if in.ID != nil {
		const prefix string = ",\"ID\":"
		first = false
		out.RawString(prefix[1:])
		(*in.ID).MarshalEasyJSON(out)
	}
	if len(in.Samples) != 0 {
		const prefix string = ",\"Samples\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v5, v6 := range in.Samples {
				if v5 > 0 {
					out.RawByte(',')
				}
				out.Int64(int64(v6))
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v SampleEntry) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding2(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v SampleEntry) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding2(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *SampleEntry) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding2(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *SampleEntry) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding2(l, v)
}
func easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding3(in *jlexer.Lexer, out *RebalanceOld) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "Buffers":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				if !in.IsDelim('}') {
					out.Buffers = make(map[string]*BufferEntryOld)
				} else {
					out.Buffers = nil
				}
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v7 *BufferEntryOld
					if in.IsNull() {
						in.Skip()
						v7 = nil
					} else {
						if v7 == nil {
							v7 = new(BufferEntryOld)
						}
						(*v7).UnmarshalEasyJSON(in)
					}
					(out.Buffers)[key] = v7
					in.WantComma()
				}
				in.Delim('}')
			}
		case "ExpiredBuffers":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				if !in.IsDelim('}') {
					out.ExpiredBuffers = make(map[string]*ExpiredBufferEntryOld)
				} else {
					out.ExpiredBuffers = nil
				}
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v8 *ExpiredBufferEntryOld
					if in.IsNull() {
						in.Skip()
						v8 = nil
					} else {
						if v8 == nil {
							v8 = new(ExpiredBufferEntryOld)
						}
						(*v8).UnmarshalEasyJSON(in)
					}
					(out.ExpiredBuffers)[key] = v8
					in.WantComma()
				}
				in.Delim('}')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding3(out *jwriter.Writer, in RebalanceOld) {
	out.RawByte('{')
	first := true
	_ = first
	if len(in.Buffers) != 0 {
		const prefix string = ",\"Buffers\":"
		first = false
		out.RawString(prefix[1:])
		{
			out.RawByte('{')
			v9First := true
			for v9Name, v9Value := range in.Buffers {
				if v9First {
					v9First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v9Name))
				out.RawByte(':')
				if v9Value == nil {
					out.RawString("null")
				} else {
					(*v9Value).MarshalEasyJSON(out)
				}
			}
			out.RawByte('}')
		}
	}
	if len(in.ExpiredBuffers) != 0 {
		const prefix string = ",\"ExpiredBuffers\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('{')
			v10First := true
			for v10Name, v10Value := range in.ExpiredBuffers {
				if v10First {
					v10First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v10Name))
				out.RawByte(':')
				if v10Value == nil {
					out.RawString("null")
				} else {
					(*v10Value).MarshalEasyJSON(out)
				}
			}
			out.RawByte('}')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v RebalanceOld) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding3(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v RebalanceOld) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding3(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *RebalanceOld) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding3(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *RebalanceOld) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding3(l, v)
}
func easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding4(in *jlexer.Lexer, out *Rebalance) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "Buffers":
			if in.IsNull() {
				in.Skip()
				out.Buffers = nil
			} else {
				in.Delim('[')
				if out.Buffers == nil {
					if !in.IsDelim(']') {
						out.Buffers = make([]*BufferEntryWithSpans, 0, 8)
					} else {
						out.Buffers = []*BufferEntryWithSpans{}
					}
				} else {
					out.Buffers = (out.Buffers)[:0]
				}
				for !in.IsDelim(']') {
					var v11 *BufferEntryWithSpans
					if in.IsNull() {
						in.Skip()
						v11 = nil
					} else {
						if v11 == nil {
							v11 = new(BufferEntryWithSpans)
						}
						(*v11).UnmarshalEasyJSON(in)
					}
					out.Buffers = append(out.Buffers, v11)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "ExpiredBuffers":
			if in.IsNull() {
				in.Skip()
				out.ExpiredBuffers = nil
			} else {
				in.Delim('[')
				if out.ExpiredBuffers == nil {
					if !in.IsDelim(']') {
						out.ExpiredBuffers = make([]*ExpiredBufferEntry, 0, 8)
					} else {
						out.ExpiredBuffers = []*ExpiredBufferEntry{}
					}
				} else {
					out.ExpiredBuffers = (out.ExpiredBuffers)[:0]
				}
				for !in.IsDelim(']') {
					var v12 *ExpiredBufferEntry
					if in.IsNull() {
						in.Skip()
						v12 = nil
					} else {
						if v12 == nil {
							v12 = new(ExpiredBufferEntry)
						}
						(*v12).UnmarshalEasyJSON(in)
					}
					out.ExpiredBuffers = append(out.ExpiredBuffers, v12)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding4(out *jwriter.Writer, in Rebalance) {
	out.RawByte('{')
	first := true
	_ = first
	if len(in.Buffers) != 0 {
		const prefix string = ",\"Buffers\":"
		first = false
		out.RawString(prefix[1:])
		{
			out.RawByte('[')
			for v13, v14 := range in.Buffers {
				if v13 > 0 {
					out.RawByte(',')
				}
				if v14 == nil {
					out.RawString("null")
				} else {
					(*v14).MarshalEasyJSON(out)
				}
			}
			out.RawByte(']')
		}
	}
	if len(in.ExpiredBuffers) != 0 {
		const prefix string = ",\"ExpiredBuffers\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v15, v16 := range in.ExpiredBuffers {
				if v15 > 0 {
					out.RawByte(',')
				}
				if v16 == nil {
					out.RawString("null")
				} else {
					(*v16).MarshalEasyJSON(out)
				}
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v Rebalance) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding4(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Rebalance) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding4(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Rebalance) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding4(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Rebalance) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding4(l, v)
}
func easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding5(in *jlexer.Lexer, out *HistoOnDiskEntry) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "Digest":
			if in.IsNull() {
				in.Skip()
				out.Digest = nil
			} else {
				out.Digest = in.Bytes()
			}
		case "Last":
			if data := in.Raw(); in.Ok() {
				in.AddError((out.Last).UnmarshalJSON(data))
			}
		case "Count":
			out.Count = int64(in.Int64())
		case "DecayedCount":
			out.DecayedCount = float64(in.Float64())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding5(out *jwriter.Writer, in HistoOnDiskEntry) {
	out.RawByte('{')
	first := true
	_ = first
	if len(in.Digest) != 0 {
		const prefix string = ",\"Digest\":"
		first = false
		out.RawString(prefix[1:])
		out.Base64Bytes(in.Digest)
	}
	if true {
		const prefix string = ",\"Last\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Raw((in.Last).MarshalJSON())
	}
	if in.Count != 0 {
		const prefix string = ",\"Count\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.Count))
	}
	if in.DecayedCount != 0 {
		const prefix string = ",\"DecayedCount\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Float64(float64(in.DecayedCount))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v HistoOnDiskEntry) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding5(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v HistoOnDiskEntry) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding5(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *HistoOnDiskEntry) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding5(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *HistoOnDiskEntry) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding5(l, v)
}
func easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding6(in *jlexer.Lexer, out *HistoOnDisk) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "Entries":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				if !in.IsDelim('}') {
					out.Entries = make(map[SpanIdentity]HistoOnDiskEntry)
				} else {
					out.Entries = nil
				}
				for !in.IsDelim('}') {
					var key SpanIdentity
					(key).UnmarshalEasyJSON(in)
					in.WantColon()
					var v20 HistoOnDiskEntry
					(v20).UnmarshalEasyJSON(in)
					(out.Entries)[key] = v20
					in.WantComma()
				}
				in.Delim('}')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding6(out *jwriter.Writer, in HistoOnDisk) {
	out.RawByte('{')
	first := true
	_ = first
	if len(in.Entries) != 0 {
		const prefix string = ",\"Entries\":"
		first = false
		out.RawString(prefix[1:])
		{
			out.RawByte('{')
			v21First := true
			for v21Name, v21Value := range in.Entries {
				if v21First {
					v21First = false
				} else {
					out.RawByte(',')
				}
				(v21Name).MarshalEasyJSON(out)
				out.RawByte(':')
				(v21Value).MarshalEasyJSON(out)
			}
			out.RawByte('}')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v HistoOnDisk) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding6(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v HistoOnDisk) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding6(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *HistoOnDisk) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding6(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *HistoOnDisk) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding6(l, v)
}
func easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding7(in *jlexer.Lexer, out *Histo) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "Error":
			if in.IsNull() {
				in.Skip()
				out.Error = nil
			} else {
				if out.Error == nil {
					out.Error = new(HistoOnDisk)
				}
				(*out.Error).UnmarshalEasyJSON(in)
			}
		case "Span":
			if in.IsNull() {
				in.Skip()
				out.Span = nil
			} else {
				if out.Span == nil {
					out.Span = new(HistoOnDisk)
				}
				(*out.Span).UnmarshalEasyJSON(in)
			}
		case "Trace":
			if in.IsNull() {
				in.Skip()
				out.Trace = nil
			} else {
				if out.Trace == nil {
					out.Trace = new(HistoOnDisk)
				}
				(*out.Trace).UnmarshalEasyJSON(in)
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding7(out *jwriter.Writer, in Histo) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Error != nil {
		const prefix string = ",\"Error\":"
		first = false
		out.RawString(prefix[1:])
		(*in.Error).MarshalEasyJSON(out)
	}
	if in.Span != nil {
		const prefix string = ",\"Span\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		(*in.Span).MarshalEasyJSON(out)
	}
	if in.Trace != nil {
		const prefix string = ",\"Trace\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		(*in.Trace).MarshalEasyJSON(out)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v Histo) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding7(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Histo) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding7(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Histo) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding7(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Histo) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding7(l, v)
}
func easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding8(in *jlexer.Lexer, out *ExpiredBufferEntryOld) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	out.BufferEntryCommon = new(BufferEntryCommon)
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "NewSpanSeen":
			out.NewSpanSeen = bool(in.Bool())
		case "Released":
			out.Released = bool(in.Bool())
		case "TraceTooLarge":
			out.TraceTooLarge = bool(in.Bool())
		case "TraceID":
			out.TraceID = string(in.String())
		case "Last":
			if data := in.Raw(); in.Ok() {
				in.AddError((out.Last).UnmarshalJSON(data))
			}
		case "LatestEndTime":
			out.LatestEndTime = int64(in.Int64())
		case "StartTime":
			out.StartTime = int64(in.Int64())
		case "Initiating":
			if in.IsNull() {
				in.Skip()
				out.Initiating = nil
			} else {
				if out.Initiating == nil {
					out.Initiating = new(trace.Span)
				}
				easyjsonE453ad8fDecodeGithubComSignalfxGolibTrace(in, out.Initiating)
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding8(out *jwriter.Writer, in ExpiredBufferEntryOld) {
	out.RawByte('{')
	first := true
	_ = first
	if in.NewSpanSeen {
		const prefix string = ",\"NewSpanSeen\":"
		first = false
		out.RawString(prefix[1:])
		out.Bool(bool(in.NewSpanSeen))
	}
	if in.Released {
		const prefix string = ",\"Released\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Bool(bool(in.Released))
	}
	if in.TraceTooLarge {
		const prefix string = ",\"TraceTooLarge\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Bool(bool(in.TraceTooLarge))
	}
	if in.TraceID != "" {
		const prefix string = ",\"TraceID\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.TraceID))
	}
	if true {
		const prefix string = ",\"Last\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Raw((in.Last).MarshalJSON())
	}
	if in.LatestEndTime != 0 {
		const prefix string = ",\"LatestEndTime\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.LatestEndTime))
	}
	if in.StartTime != 0 {
		const prefix string = ",\"StartTime\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.StartTime))
	}
	if in.Initiating != nil {
		const prefix string = ",\"Initiating\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		easyjsonE453ad8fEncodeGithubComSignalfxGolibTrace(out, *in.Initiating)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v ExpiredBufferEntryOld) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding8(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v ExpiredBufferEntryOld) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding8(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *ExpiredBufferEntryOld) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding8(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *ExpiredBufferEntryOld) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding8(l, v)
}
func easyjsonE453ad8fDecodeGithubComSignalfxGolibTrace(in *jlexer.Lexer, out *trace.Span) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "traceId":
			out.TraceID = string(in.String())
		case "name":
			if in.IsNull() {
				in.Skip()
				out.Name = nil
			} else {
				if out.Name == nil {
					out.Name = new(string)
				}
				*out.Name = string(in.String())
			}
		case "parentId":
			if in.IsNull() {
				in.Skip()
				out.ParentID = nil
			} else {
				if out.ParentID == nil {
					out.ParentID = new(string)
				}
				*out.ParentID = string(in.String())
			}
		case "id":
			out.ID = string(in.String())
		case "kind":
			if in.IsNull() {
				in.Skip()
				out.Kind = nil
			} else {
				if out.Kind == nil {
					out.Kind = new(string)
				}
				*out.Kind = string(in.String())
			}
		case "timestamp":
			if in.IsNull() {
				in.Skip()
				out.Timestamp = nil
			} else {
				if out.Timestamp == nil {
					out.Timestamp = new(int64)
				}
				*out.Timestamp = int64(in.Int64())
			}
		case "duration":
			if in.IsNull() {
				in.Skip()
				out.Duration = nil
			} else {
				if out.Duration == nil {
					out.Duration = new(int64)
				}
				*out.Duration = int64(in.Int64())
			}
		case "debug":
			if in.IsNull() {
				in.Skip()
				out.Debug = nil
			} else {
				if out.Debug == nil {
					out.Debug = new(bool)
				}
				*out.Debug = bool(in.Bool())
			}
		case "shared":
			if in.IsNull() {
				in.Skip()
				out.Shared = nil
			} else {
				if out.Shared == nil {
					out.Shared = new(bool)
				}
				*out.Shared = bool(in.Bool())
			}
		case "localEndpoint":
			if in.IsNull() {
				in.Skip()
				out.LocalEndpoint = nil
			} else {
				if out.LocalEndpoint == nil {
					out.LocalEndpoint = new(trace.Endpoint)
				}
				easyjsonE453ad8fDecodeGithubComSignalfxGolibTrace1(in, out.LocalEndpoint)
			}
		case "remoteEndpoint":
			if in.IsNull() {
				in.Skip()
				out.RemoteEndpoint = nil
			} else {
				if out.RemoteEndpoint == nil {
					out.RemoteEndpoint = new(trace.Endpoint)
				}
				easyjsonE453ad8fDecodeGithubComSignalfxGolibTrace1(in, out.RemoteEndpoint)
			}
		case "annotations":
			if in.IsNull() {
				in.Skip()
				out.Annotations = nil
			} else {
				in.Delim('[')
				if out.Annotations == nil {
					if !in.IsDelim(']') {
						out.Annotations = make([]*trace.Annotation, 0, 8)
					} else {
						out.Annotations = []*trace.Annotation{}
					}
				} else {
					out.Annotations = (out.Annotations)[:0]
				}
				for !in.IsDelim(']') {
					var v22 *trace.Annotation
					if in.IsNull() {
						in.Skip()
						v22 = nil
					} else {
						if v22 == nil {
							v22 = new(trace.Annotation)
						}
						easyjsonE453ad8fDecodeGithubComSignalfxGolibTrace2(in, v22)
					}
					out.Annotations = append(out.Annotations, v22)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "tags":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				if !in.IsDelim('}') {
					out.Tags = make(map[string]string)
				} else {
					out.Tags = nil
				}
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v23 string
					v23 = string(in.String())
					(out.Tags)[key] = v23
					in.WantComma()
				}
				in.Delim('}')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonE453ad8fEncodeGithubComSignalfxGolibTrace(out *jwriter.Writer, in trace.Span) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"traceId\":"
		out.RawString(prefix[1:])
		out.String(string(in.TraceID))
	}
	if in.Name != nil {
		const prefix string = ",\"name\":"
		out.RawString(prefix)
		out.String(string(*in.Name))
	}
	if in.ParentID != nil {
		const prefix string = ",\"parentId\":"
		out.RawString(prefix)
		out.String(string(*in.ParentID))
	}
	{
		const prefix string = ",\"id\":"
		out.RawString(prefix)
		out.String(string(in.ID))
	}
	if in.Kind != nil {
		const prefix string = ",\"kind\":"
		out.RawString(prefix)
		out.String(string(*in.Kind))
	}
	if in.Timestamp != nil {
		const prefix string = ",\"timestamp\":"
		out.RawString(prefix)
		out.Int64(int64(*in.Timestamp))
	}
	if in.Duration != nil {
		const prefix string = ",\"duration\":"
		out.RawString(prefix)
		out.Int64(int64(*in.Duration))
	}
	if in.Debug != nil {
		const prefix string = ",\"debug\":"
		out.RawString(prefix)
		out.Bool(bool(*in.Debug))
	}
	if in.Shared != nil {
		const prefix string = ",\"shared\":"
		out.RawString(prefix)
		out.Bool(bool(*in.Shared))
	}
	if in.LocalEndpoint != nil {
		const prefix string = ",\"localEndpoint\":"
		out.RawString(prefix)
		easyjsonE453ad8fEncodeGithubComSignalfxGolibTrace1(out, *in.LocalEndpoint)
	}
	if in.RemoteEndpoint != nil {
		const prefix string = ",\"remoteEndpoint\":"
		out.RawString(prefix)
		easyjsonE453ad8fEncodeGithubComSignalfxGolibTrace1(out, *in.RemoteEndpoint)
	}
	if len(in.Annotations) != 0 {
		const prefix string = ",\"annotations\":"
		out.RawString(prefix)
		{
			out.RawByte('[')
			for v24, v25 := range in.Annotations {
				if v24 > 0 {
					out.RawByte(',')
				}
				if v25 == nil {
					out.RawString("null")
				} else {
					easyjsonE453ad8fEncodeGithubComSignalfxGolibTrace2(out, *v25)
				}
			}
			out.RawByte(']')
		}
	}
	if len(in.Tags) != 0 {
		const prefix string = ",\"tags\":"
		out.RawString(prefix)
		{
			out.RawByte('{')
			v26First := true
			for v26Name, v26Value := range in.Tags {
				if v26First {
					v26First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v26Name))
				out.RawByte(':')
				out.String(string(v26Value))
			}
			out.RawByte('}')
		}
	}
	out.RawByte('}')
}
func easyjsonE453ad8fDecodeGithubComSignalfxGolibTrace2(in *jlexer.Lexer, out *trace.Annotation) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "timestamp":
			if in.IsNull() {
				in.Skip()
				out.Timestamp = nil
			} else {
				if out.Timestamp == nil {
					out.Timestamp = new(int64)
				}
				*out.Timestamp = int64(in.Int64())
			}
		case "value":
			if in.IsNull() {
				in.Skip()
				out.Value = nil
			} else {
				if out.Value == nil {
					out.Value = new(string)
				}
				*out.Value = string(in.String())
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonE453ad8fEncodeGithubComSignalfxGolibTrace2(out *jwriter.Writer, in trace.Annotation) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Timestamp != nil {
		const prefix string = ",\"timestamp\":"
		first = false
		out.RawString(prefix[1:])
		out.Int64(int64(*in.Timestamp))
	}
	if in.Value != nil {
		const prefix string = ",\"value\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(*in.Value))
	}
	out.RawByte('}')
}
func easyjsonE453ad8fDecodeGithubComSignalfxGolibTrace1(in *jlexer.Lexer, out *trace.Endpoint) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "serviceName":
			if in.IsNull() {
				in.Skip()
				out.ServiceName = nil
			} else {
				if out.ServiceName == nil {
					out.ServiceName = new(string)
				}
				*out.ServiceName = string(in.String())
			}
		case "ipv4":
			if in.IsNull() {
				in.Skip()
				out.Ipv4 = nil
			} else {
				if out.Ipv4 == nil {
					out.Ipv4 = new(string)
				}
				*out.Ipv4 = string(in.String())
			}
		case "ipv6":
			if in.IsNull() {
				in.Skip()
				out.Ipv6 = nil
			} else {
				if out.Ipv6 == nil {
					out.Ipv6 = new(string)
				}
				*out.Ipv6 = string(in.String())
			}
		case "port":
			if in.IsNull() {
				in.Skip()
				out.Port = nil
			} else {
				if out.Port == nil {
					out.Port = new(int32)
				}
				*out.Port = int32(in.Int32())
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonE453ad8fEncodeGithubComSignalfxGolibTrace1(out *jwriter.Writer, in trace.Endpoint) {
	out.RawByte('{')
	first := true
	_ = first
	if in.ServiceName != nil {
		const prefix string = ",\"serviceName\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(*in.ServiceName))
	}
	if in.Ipv4 != nil {
		const prefix string = ",\"ipv4\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(*in.Ipv4))
	}
	if in.Ipv6 != nil {
		const prefix string = ",\"ipv6\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(*in.Ipv6))
	}
	if in.Port != nil {
		const prefix string = ",\"port\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int32(int32(*in.Port))
	}
	out.RawByte('}')
}
func easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding9(in *jlexer.Lexer, out *ExpiredBufferEntry) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "TraceID":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('[')
				v27 := 0
				for !in.IsDelim(']') {
					if v27 < 2 {
						(out.TraceID)[v27] = uint64(in.Uint64())
						v27++
					} else {
						in.SkipRecursive()
					}
					in.WantComma()
				}
				in.Delim(']')
			}
		case "Last":
			out.Last = int64(in.Int64())
		case "LatestEndTime":
			out.LatestEndTime = int64(in.Int64())
		case "StartTime":
			out.StartTime = int64(in.Int64())
		case "InitiatingIdentity":
			(out.InitiatingIdentity).UnmarshalEasyJSON(in)
		case "NewSpanSeen":
			out.NewSpanSeen = bool(in.Bool())
		case "Released":
			out.Released = bool(in.Bool())
		case "TraceTooLarge":
			out.TraceTooLarge = bool(in.Bool())
		case "DefinitiveTraceID":
			out.DefinitiveTraceID = bool(in.Bool())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding9(out *jwriter.Writer, in ExpiredBufferEntry) {
	out.RawByte('{')
	first := true
	_ = first
	if true {
		const prefix string = ",\"TraceID\":"
		first = false
		out.RawString(prefix[1:])
		out.RawByte('[')
		for v28 := range in.TraceID {
			if v28 > 0 {
				out.RawByte(',')
			}
			out.Uint64(uint64((in.TraceID)[v28]))
		}
		out.RawByte(']')
	}
	if in.Last != 0 {
		const prefix string = ",\"Last\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.Last))
	}
	if in.LatestEndTime != 0 {
		const prefix string = ",\"LatestEndTime\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.LatestEndTime))
	}
	if in.StartTime != 0 {
		const prefix string = ",\"StartTime\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.StartTime))
	}
	if true {
		const prefix string = ",\"InitiatingIdentity\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		(in.InitiatingIdentity).MarshalEasyJSON(out)
	}
	if in.NewSpanSeen {
		const prefix string = ",\"NewSpanSeen\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Bool(bool(in.NewSpanSeen))
	}
	if in.Released {
		const prefix string = ",\"Released\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Bool(bool(in.Released))
	}
	if in.TraceTooLarge {
		const prefix string = ",\"TraceTooLarge\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Bool(bool(in.TraceTooLarge))
	}
	if in.DefinitiveTraceID {
		const prefix string = ",\"DefinitiveTraceID\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Bool(bool(in.DefinitiveTraceID))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v ExpiredBufferEntry) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding9(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v ExpiredBufferEntry) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding9(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *ExpiredBufferEntry) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding9(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *ExpiredBufferEntry) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding9(l, v)
}
func easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding10(in *jlexer.Lexer, out *ExpiredBufferEntries) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		in.Skip()
		*out = nil
	} else {
		in.Delim('[')
		if *out == nil {
			if !in.IsDelim(']') {
				*out = make(ExpiredBufferEntries, 0, 8)
			} else {
				*out = ExpiredBufferEntries{}
			}
		} else {
			*out = (*out)[:0]
		}
		for !in.IsDelim(']') {
			var v29 *ExpiredBufferEntry
			if in.IsNull() {
				in.Skip()
				v29 = nil
			} else {
				if v29 == nil {
					v29 = new(ExpiredBufferEntry)
				}
				(*v29).UnmarshalEasyJSON(in)
			}
			*out = append(*out, v29)
			in.WantComma()
		}
		in.Delim(']')
	}
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding10(out *jwriter.Writer, in ExpiredBufferEntries) {
	if in == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
		out.RawString("null")
	} else {
		out.RawByte('[')
		for v30, v31 := range in {
			if v30 > 0 {
				out.RawByte(',')
			}
			if v31 == nil {
				out.RawString("null")
			} else {
				(*v31).MarshalEasyJSON(out)
			}
		}
		out.RawByte(']')
	}
}

// MarshalJSON supports json.Marshaler interface
func (v ExpiredBufferEntries) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding10(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v ExpiredBufferEntries) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding10(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *ExpiredBufferEntries) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding10(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *ExpiredBufferEntries) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding10(l, v)
}
func easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding11(in *jlexer.Lexer, out *EtcdConfig) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "RebalanceAddress":
			out.RebalanceAddress = string(in.String())
		case "IngestAddress":
			out.IngestAddress = string(in.String())
		case "ID":
			out.ID = string(in.String())
		case "Weight":
			out.Weight = int32(in.Int32())
		case "Version":
			out.Version = int32(in.Int32())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding11(out *jwriter.Writer, in EtcdConfig) {
	out.RawByte('{')
	first := true
	_ = first
	if in.RebalanceAddress != "" {
		const prefix string = ",\"RebalanceAddress\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.RebalanceAddress))
	}
	if in.IngestAddress != "" {
		const prefix string = ",\"IngestAddress\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.IngestAddress))
	}
	if in.ID != "" {
		const prefix string = ",\"ID\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.ID))
	}
	if in.Weight != 0 {
		const prefix string = ",\"Weight\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int32(int32(in.Weight))
	}
	if in.Version != 0 {
		const prefix string = ",\"Version\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int32(int32(in.Version))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v EtcdConfig) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding11(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v EtcdConfig) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding11(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *EtcdConfig) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding11(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *EtcdConfig) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding11(l, v)
}
func easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding12(in *jlexer.Lexer, out *BufferOnDisk) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "NumSpans":
			out.NumSpans = int64(in.Int64())
		case "Entries":
			if in.IsNull() {
				in.Skip()
				out.Entries = nil
			} else {
				in.Delim('[')
				if out.Entries == nil {
					if !in.IsDelim(']') {
						out.Entries = make([]BufferEntry, 0, 1)
					} else {
						out.Entries = []BufferEntry{}
					}
				} else {
					out.Entries = (out.Entries)[:0]
				}
				for !in.IsDelim(']') {
					var v32 BufferEntry
					(v32).UnmarshalEasyJSON(in)
					out.Entries = append(out.Entries, v32)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "ExpiredEntries":
			if in.IsNull() {
				in.Skip()
				out.ExpiredEntries = nil
			} else {
				in.Delim('[')
				if out.ExpiredEntries == nil {
					if !in.IsDelim(']') {
						out.ExpiredEntries = make([]ExpiredBufferEntry, 0, 1)
					} else {
						out.ExpiredEntries = []ExpiredBufferEntry{}
					}
				} else {
					out.ExpiredEntries = (out.ExpiredEntries)[:0]
				}
				for !in.IsDelim(']') {
					var v33 ExpiredBufferEntry
					(v33).UnmarshalEasyJSON(in)
					out.ExpiredEntries = append(out.ExpiredEntries, v33)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "EntryMap":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				if !in.IsDelim('}') {
					out.EntryMap = make(map[string]int)
				} else {
					out.EntryMap = nil
				}
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v34 int
					v34 = int(in.Int())
					(out.EntryMap)[key] = v34
					in.WantComma()
				}
				in.Delim('}')
			}
		case "ExpiredMap":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				if !in.IsDelim('}') {
					out.ExpiredMap = make(map[string]int)
				} else {
					out.ExpiredMap = nil
				}
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v35 int
					v35 = int(in.Int())
					(out.ExpiredMap)[key] = v35
					in.WantComma()
				}
				in.Delim('}')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding12(out *jwriter.Writer, in BufferOnDisk) {
	out.RawByte('{')
	first := true
	_ = first
	if in.NumSpans != 0 {
		const prefix string = ",\"NumSpans\":"
		first = false
		out.RawString(prefix[1:])
		out.Int64(int64(in.NumSpans))
	}
	if len(in.Entries) != 0 {
		const prefix string = ",\"Entries\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v36, v37 := range in.Entries {
				if v36 > 0 {
					out.RawByte(',')
				}
				(v37).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	if len(in.ExpiredEntries) != 0 {
		const prefix string = ",\"ExpiredEntries\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v38, v39 := range in.ExpiredEntries {
				if v38 > 0 {
					out.RawByte(',')
				}
				(v39).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	if len(in.EntryMap) != 0 {
		const prefix string = ",\"EntryMap\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('{')
			v40First := true
			for v40Name, v40Value := range in.EntryMap {
				if v40First {
					v40First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v40Name))
				out.RawByte(':')
				out.Int(int(v40Value))
			}
			out.RawByte('}')
		}
	}
	if len(in.ExpiredMap) != 0 {
		const prefix string = ",\"ExpiredMap\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('{')
			v41First := true
			for v41Name, v41Value := range in.ExpiredMap {
				if v41First {
					v41First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v41Name))
				out.RawByte(':')
				out.Int(int(v41Value))
			}
			out.RawByte('}')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v BufferOnDisk) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding12(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v BufferOnDisk) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding12(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *BufferOnDisk) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding12(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *BufferOnDisk) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding12(l, v)
}
func easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding13(in *jlexer.Lexer, out *BufferEntryWithSpans) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "Spans":
			if in.IsNull() {
				in.Skip()
				out.Spans = nil
			} else {
				in.Delim('[')
				if out.Spans == nil {
					if !in.IsDelim(']') {
						out.Spans = make([][]uint8, 0, 2)
					} else {
						out.Spans = [][]uint8{}
					}
				} else {
					out.Spans = (out.Spans)[:0]
				}
				for !in.IsDelim(']') {
					var v42 []uint8
					if in.IsNull() {
						in.Skip()
						v42 = nil
					} else {
						v42 = in.Bytes()
					}
					out.Spans = append(out.Spans, v42)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "TraceID":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('[')
				v44 := 0
				for !in.IsDelim(']') {
					if v44 < 2 {
						(out.TraceID)[v44] = uint64(in.Uint64())
						v44++
					} else {
						in.SkipRecursive()
					}
					in.WantComma()
				}
				in.Delim(']')
			}
		case "Last":
			out.Last = int64(in.Int64())
		case "LatestEndTime":
			out.LatestEndTime = int64(in.Int64())
		case "FirstWallclock":
			out.FirstWallclock = int64(in.Int64())
		case "LastWallClock":
			out.LastWallClock = int64(in.Int64())
		case "SizeSoFar":
			out.SizeSoFar = int64(in.Int64())
		case "Initiating":
			if in.IsNull() {
				in.Skip()
				out.Initiating = nil
			} else {
				if out.Initiating == nil {
					out.Initiating = new(trace.Span)
				}
				easyjsonE453ad8fDecodeGithubComSignalfxGolibTrace(in, out.Initiating)
			}
		case "CountOfSpans":
			out.CountOfSpans = int32(in.Int32())
		case "ToBeReleased":
			out.ToBeReleased = bool(in.Bool())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding13(out *jwriter.Writer, in BufferEntryWithSpans) {
	out.RawByte('{')
	first := true
	_ = first
	if len(in.Spans) != 0 {
		const prefix string = ",\"Spans\":"
		first = false
		out.RawString(prefix[1:])
		{
			out.RawByte('[')
			for v45, v46 := range in.Spans {
				if v45 > 0 {
					out.RawByte(',')
				}
				out.Base64Bytes(v46)
			}
			out.RawByte(']')
		}
	}
	if true {
		const prefix string = ",\"TraceID\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.RawByte('[')
		for v49 := range in.TraceID {
			if v49 > 0 {
				out.RawByte(',')
			}
			out.Uint64(uint64((in.TraceID)[v49]))
		}
		out.RawByte(']')
	}
	if in.Last != 0 {
		const prefix string = ",\"Last\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.Last))
	}
	if in.LatestEndTime != 0 {
		const prefix string = ",\"LatestEndTime\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.LatestEndTime))
	}
	if in.FirstWallclock != 0 {
		const prefix string = ",\"FirstWallclock\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.FirstWallclock))
	}
	if in.LastWallClock != 0 {
		const prefix string = ",\"LastWallClock\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.LastWallClock))
	}
	if in.SizeSoFar != 0 {
		const prefix string = ",\"SizeSoFar\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.SizeSoFar))
	}
	if in.Initiating != nil {
		const prefix string = ",\"Initiating\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		easyjsonE453ad8fEncodeGithubComSignalfxGolibTrace(out, *in.Initiating)
	}
	if in.CountOfSpans != 0 {
		const prefix string = ",\"CountOfSpans\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int32(int32(in.CountOfSpans))
	}
	if in.ToBeReleased {
		const prefix string = ",\"ToBeReleased\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Bool(bool(in.ToBeReleased))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v BufferEntryWithSpans) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding13(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v BufferEntryWithSpans) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding13(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *BufferEntryWithSpans) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding13(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *BufferEntryWithSpans) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding13(l, v)
}
func easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding14(in *jlexer.Lexer, out *BufferEntryOld) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	out.BufferEntryCommon = new(BufferEntryCommon)
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "Spans":
			if in.IsNull() {
				in.Skip()
				out.Spans = nil
			} else {
				in.Delim('[')
				if out.Spans == nil {
					if !in.IsDelim(']') {
						out.Spans = make([]*trace.Span, 0, 8)
					} else {
						out.Spans = []*trace.Span{}
					}
				} else {
					out.Spans = (out.Spans)[:0]
				}
				for !in.IsDelim(']') {
					var v50 *trace.Span
					if in.IsNull() {
						in.Skip()
						v50 = nil
					} else {
						if v50 == nil {
							v50 = new(trace.Span)
						}
						easyjsonE453ad8fDecodeGithubComSignalfxGolibTrace(in, v50)
					}
					out.Spans = append(out.Spans, v50)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "SizeSoFar":
			out.SizeSoFar = int64(in.Int64())
		case "ToBeReleased":
			out.ToBeReleased = bool(in.Bool())
		case "TraceID":
			out.TraceID = string(in.String())
		case "Last":
			if data := in.Raw(); in.Ok() {
				in.AddError((out.Last).UnmarshalJSON(data))
			}
		case "LatestEndTime":
			out.LatestEndTime = int64(in.Int64())
		case "StartTime":
			out.StartTime = int64(in.Int64())
		case "Initiating":
			if in.IsNull() {
				in.Skip()
				out.Initiating = nil
			} else {
				if out.Initiating == nil {
					out.Initiating = new(trace.Span)
				}
				easyjsonE453ad8fDecodeGithubComSignalfxGolibTrace(in, out.Initiating)
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding14(out *jwriter.Writer, in BufferEntryOld) {
	out.RawByte('{')
	first := true
	_ = first
	if len(in.Spans) != 0 {
		const prefix string = ",\"Spans\":"
		first = false
		out.RawString(prefix[1:])
		{
			out.RawByte('[')
			for v51, v52 := range in.Spans {
				if v51 > 0 {
					out.RawByte(',')
				}
				if v52 == nil {
					out.RawString("null")
				} else {
					easyjsonE453ad8fEncodeGithubComSignalfxGolibTrace(out, *v52)
				}
			}
			out.RawByte(']')
		}
	}
	if in.SizeSoFar != 0 {
		const prefix string = ",\"SizeSoFar\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.SizeSoFar))
	}
	if in.ToBeReleased {
		const prefix string = ",\"ToBeReleased\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Bool(bool(in.ToBeReleased))
	}
	if in.TraceID != "" {
		const prefix string = ",\"TraceID\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.TraceID))
	}
	if true {
		const prefix string = ",\"Last\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Raw((in.Last).MarshalJSON())
	}
	if in.LatestEndTime != 0 {
		const prefix string = ",\"LatestEndTime\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.LatestEndTime))
	}
	if in.StartTime != 0 {
		const prefix string = ",\"StartTime\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.StartTime))
	}
	if in.Initiating != nil {
		const prefix string = ",\"Initiating\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		easyjsonE453ad8fEncodeGithubComSignalfxGolibTrace(out, *in.Initiating)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v BufferEntryOld) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding14(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v BufferEntryOld) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding14(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *BufferEntryOld) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding14(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *BufferEntryOld) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding14(l, v)
}
func easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding15(in *jlexer.Lexer, out *BufferEntryCommon) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "TraceID":
			out.TraceID = string(in.String())
		case "Last":
			if data := in.Raw(); in.Ok() {
				in.AddError((out.Last).UnmarshalJSON(data))
			}
		case "LatestEndTime":
			out.LatestEndTime = int64(in.Int64())
		case "StartTime":
			out.StartTime = int64(in.Int64())
		case "Initiating":
			if in.IsNull() {
				in.Skip()
				out.Initiating = nil
			} else {
				if out.Initiating == nil {
					out.Initiating = new(trace.Span)
				}
				easyjsonE453ad8fDecodeGithubComSignalfxGolibTrace(in, out.Initiating)
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding15(out *jwriter.Writer, in BufferEntryCommon) {
	out.RawByte('{')
	first := true
	_ = first
	if in.TraceID != "" {
		const prefix string = ",\"TraceID\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.TraceID))
	}
	if true {
		const prefix string = ",\"Last\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Raw((in.Last).MarshalJSON())
	}
	if in.LatestEndTime != 0 {
		const prefix string = ",\"LatestEndTime\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.LatestEndTime))
	}
	if in.StartTime != 0 {
		const prefix string = ",\"StartTime\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.StartTime))
	}
	if in.Initiating != nil {
		const prefix string = ",\"Initiating\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		easyjsonE453ad8fEncodeGithubComSignalfxGolibTrace(out, *in.Initiating)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v BufferEntryCommon) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding15(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v BufferEntryCommon) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding15(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *BufferEntryCommon) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding15(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *BufferEntryCommon) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding15(l, v)
}
func easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding16(in *jlexer.Lexer, out *BufferEntry) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "TraceID":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('[')
				v53 := 0
				for !in.IsDelim(']') {
					if v53 < 2 {
						(out.TraceID)[v53] = uint64(in.Uint64())
						v53++
					} else {
						in.SkipRecursive()
					}
					in.WantComma()
				}
				in.Delim(']')
			}
		case "Last":
			out.Last = int64(in.Int64())
		case "LatestEndTime":
			out.LatestEndTime = int64(in.Int64())
		case "FirstWallclock":
			out.FirstWallclock = int64(in.Int64())
		case "LastWallClock":
			out.LastWallClock = int64(in.Int64())
		case "SizeSoFar":
			out.SizeSoFar = int64(in.Int64())
		case "Initiating":
			if in.IsNull() {
				in.Skip()
				out.Initiating = nil
			} else {
				if out.Initiating == nil {
					out.Initiating = new(trace.Span)
				}
				easyjsonE453ad8fDecodeGithubComSignalfxGolibTrace(in, out.Initiating)
			}
		case "CountOfSpans":
			out.CountOfSpans = int32(in.Int32())
		case "ToBeReleased":
			out.ToBeReleased = bool(in.Bool())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding16(out *jwriter.Writer, in BufferEntry) {
	out.RawByte('{')
	first := true
	_ = first
	if true {
		const prefix string = ",\"TraceID\":"
		first = false
		out.RawString(prefix[1:])
		out.RawByte('[')
		for v54 := range in.TraceID {
			if v54 > 0 {
				out.RawByte(',')
			}
			out.Uint64(uint64((in.TraceID)[v54]))
		}
		out.RawByte(']')
	}
	if in.Last != 0 {
		const prefix string = ",\"Last\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.Last))
	}
	if in.LatestEndTime != 0 {
		const prefix string = ",\"LatestEndTime\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.LatestEndTime))
	}
	if in.FirstWallclock != 0 {
		const prefix string = ",\"FirstWallclock\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.FirstWallclock))
	}
	if in.LastWallClock != 0 {
		const prefix string = ",\"LastWallClock\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.LastWallClock))
	}
	if in.SizeSoFar != 0 {
		const prefix string = ",\"SizeSoFar\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.SizeSoFar))
	}
	if in.Initiating != nil {
		const prefix string = ",\"Initiating\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		easyjsonE453ad8fEncodeGithubComSignalfxGolibTrace(out, *in.Initiating)
	}
	if in.CountOfSpans != 0 {
		const prefix string = ",\"CountOfSpans\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int32(int32(in.CountOfSpans))
	}
	if in.ToBeReleased {
		const prefix string = ",\"ToBeReleased\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Bool(bool(in.ToBeReleased))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v BufferEntry) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding16(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v BufferEntry) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding16(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *BufferEntry) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding16(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *BufferEntry) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding16(l, v)
}
func easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding17(in *jlexer.Lexer, out *BufferEntriesWithSpans) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		in.Skip()
		*out = nil
	} else {
		in.Delim('[')
		if *out == nil {
			if !in.IsDelim(']') {
				*out = make(BufferEntriesWithSpans, 0, 8)
			} else {
				*out = BufferEntriesWithSpans{}
			}
		} else {
			*out = (*out)[:0]
		}
		for !in.IsDelim(']') {
			var v55 *BufferEntryWithSpans
			if in.IsNull() {
				in.Skip()
				v55 = nil
			} else {
				if v55 == nil {
					v55 = new(BufferEntryWithSpans)
				}
				(*v55).UnmarshalEasyJSON(in)
			}
			*out = append(*out, v55)
			in.WantComma()
		}
		in.Delim(']')
	}
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding17(out *jwriter.Writer, in BufferEntriesWithSpans) {
	if in == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
		out.RawString("null")
	} else {
		out.RawByte('[')
		for v56, v57 := range in {
			if v56 > 0 {
				out.RawByte(',')
			}
			if v57 == nil {
				out.RawString("null")
			} else {
				(*v57).MarshalEasyJSON(out)
			}
		}
		out.RawByte(']')
	}
}

// MarshalJSON supports json.Marshaler interface
func (v BufferEntriesWithSpans) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding17(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v BufferEntriesWithSpans) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonE453ad8fEncodeGithubComSignalfxOndiskencoding17(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *BufferEntriesWithSpans) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding17(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *BufferEntriesWithSpans) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonE453ad8fDecodeGithubComSignalfxOndiskencoding17(l, v)
}
